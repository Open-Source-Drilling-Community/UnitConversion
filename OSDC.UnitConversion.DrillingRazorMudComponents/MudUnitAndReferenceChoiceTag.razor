@if (unitChoiceSets == null)
{
    <p><em>Loading...</em></p>
}
else
{
    <table class="table">
        <tbody>
            <tr>
                <td width="18%">
                    <MudSelect @bind-Value="UnitChoiceSetName" Label="UnitChoiceSet" Variant="Variant.Filled">
                        @foreach (MetaInfo metaInfo in unitChoiceSets)
                        {
                            <MudSelectItem Value="@metaInfo.Name">@metaInfo.Name</MudSelectItem>
                        }
                    </MudSelect>
                </td>
                <td width="16%">
                    <MudSelect @bind-Value="depthReferenceName_" Label="Depth Reference" Variant="Variant.Filled" Disabled="@IsHiddenDepthReference">
                        @foreach (Tuple<Guid, string> tuple in depthReferences)
                        {
                            <MudSelectItem Value="@tuple.Item2">@tuple.Item2</MudSelectItem>
                        }
                    </MudSelect>
                </td>

                <td width="16%">
                    <MudSelect @bind-Value="positionReferenceName_" Label="Position Reference" Variant="Variant.Filled" Disabled="@IsHiddenPositionReference">
                        @foreach (Tuple<Guid, string> tuple in positionReferences)
                        {
                            <MudSelectItem Value="@tuple.Item2">@tuple.Item2</MudSelectItem>
                        }
                    </MudSelect>
                </td>
                <td width="16%">
                    <MudSelect @bind-Value="azimuthReferenceName_" Label="Azimuth Reference" Variant="Variant.Filled" Disabled="@IsHiddenAzimuthReference">
                        @foreach (Tuple<Guid, string> tuple in azimuthReferences)
                        {
                            <MudSelectItem Value="@tuple.Item2">@tuple.Item2</MudSelectItem>
                        }
                    </MudSelect>
                </td>
                <td width="16%">
                    <MudSelect @bind-Value="pressureReferenceName_" Label="Pressure Reference" Variant="Variant.Filled" Disabled="@IsHiddenPressureReference">
                        @foreach (Tuple<Guid, string> tuple in pressureReferences)
                        {
                            <MudSelectItem Value="@tuple.Item2">@tuple.Item2</MudSelectItem>
                        }
                    </MudSelect>
                </td>
                <td width="18%">
                    <MudSelect @bind-Value="DateReferenceName" Label="Date Reference" Variant="Variant.Filled">
                        @foreach (Tuple<Guid, string> tuple in dateReferences)
                        {
                            <MudSelectItem Value="@tuple.Item2">@tuple.Item2</MudSelectItem>
                        }
                    </MudSelect>
                </td>
            </tr>
        </tbody>
    </table>
    <CascadingValue Value="this">
        @ChildContent
    </CascadingValue>
}
@code {
    [Parameter]
    public RenderFragment ChildContent { get; set; }

    [Parameter]
    public string HttpHost { get; set; }

    [Parameter]
    public string HttpBasePath { get; set; }

    [Parameter]
    public string HttpController { get; set; }

    [Parameter]
    public IGaugeReferencePressureSource GaugeReferencePressureSource { get; set; }

    [Parameter]
    public IGridConvergenceSource GridConvergenceSource { get; set; }

    [Parameter]
    public IMagneticDeclinationSource MagneticDeclinationSource { get; set; }

    [Parameter]
    public ICartographicGridPositionReferenceSource CartographicGridPositionReferenceSource { get; set; }

    [Parameter]
    public ILeaseLinePositionReferenceSource LeaseLinePositionReferenceSource { get; set; }

    [Parameter]
    public IClusterPositionReferenceSource ClusterPositionReferenceSource { get; set; }

    [Parameter]
    public IWellHeadPositionReferenceSource WellHeadPositionReferenceSource { get; set; }

    [Parameter]
    public IWellHeadDepthReferenceSource WellHeadDepthReferenceSource { get; set; }

    [Parameter]
    public IGroundMudLineDepthReferenceSource GroundMudLineDepthReferenceSource { get; set; }

    [Parameter]
    public ISeaWaterLevelDepthReferenceSource SeaWaterLevelDepthReferenceSource { get; set; }

    [Parameter]
    public IRotaryTableDepthReferenceSource RotaryTableDepthReferenceSource { get; set; }

    [Parameter]
    public string UnitChoiceSetName
    {
        get
        {
            return unitChoiceSetName_;
        }
        set
        {
            //High risk of entering infinite loop while rendering parent and children components (https://learn.microsoft.com/en-us/aspnet/core/blazor/components/?view=aspnetcore-3.1#overwritten-parameters-2)
            //Still, these components need to be initialized or updated as long as some fundamental variables are not set, which is ensure by the condition below
            if (unitChoiceSetName_ == null || !unitChoiceSetName_.Equals(value) || unitChoiceSet_ == null)
            {
                unitChoiceSetName_ = value;
                PostProcessUnitChoiceSet();
            }
        }
    }

    [Parameter]
    public EventCallback<string?> UnitChoiceSetNameChanged { get; set; }

    private string unitChoiceSetName_;
    private string depthReferenceName_;
    private string positionReferenceName_;
    private string azimuthReferenceName_;
    private string pressureReferenceName_;
    public string DateReferenceName;

    private HttpClient httpClient;
    private List<MetaInfo> unitChoiceSets = new List<MetaInfo>();
    private List<Tuple<Guid, string>> depthReferences = new List<Tuple<Guid, string>>();
    private List<Tuple<Guid, string>> positionReferences = new List<Tuple<Guid, string>>();
    private List<Tuple<Guid, string>> azimuthReferences = new List<Tuple<Guid, string>>();
    private List<Tuple<Guid, string>> pressureReferences = new List<Tuple<Guid, string>>();
    private List<Tuple<Guid, string>> dateReferences = new List<Tuple<Guid, string>>();

    private List<IUnitAwareComponent> unitAwareComponents_ = new List<IUnitAwareComponent>();
    private List<IDateTimeReferenceAwareComponent> dateTimeAwareComponents_ = new List<IDateTimeReferenceAwareComponent>();

    private UnitChoiceSet unitChoiceSet_;

    private bool IsHiddenPositionReference = false;
    private bool IsHiddenDepthReference = false;
    private bool IsHiddenAzimuthReference = false;
    private bool IsHiddenPressureReference = false;

    protected override async Task OnInitializedAsync()
    {
        try
        {
            depthReferences.Add(new Tuple<Guid, string>(new Guid("41c23e00-2fe4-4787-b005-89d962207e97"), "WGS84"));
            if (RotaryTableDepthReferenceSource != null)
            {
                depthReferences.Add(new Tuple<Guid, string>(new Guid("4d4fd143-b00d-4575-b9f2-a7ea4047e9d3"), "Rotary table"));
            }
            if (SeaWaterLevelDepthReferenceSource != null)
            {
                depthReferences.Add(new Tuple<Guid, string>(new Guid("98f55f50-e9e1-4045-8b2f-b03e6b96e1d1"), "Sea/Water Level"));
            }
            if (GroundMudLineDepthReferenceSource != null)
            {
                depthReferences.Add(new Tuple<Guid, string>(new Guid("a4667d26-3bb2-40ac-b26f-9346d1441e4a"), "Mud-line/Ground Level"));
            }
            if (WellHeadPositionReferenceSource != null)
            {
                depthReferences.Add(new Tuple<Guid, string>(new Guid("51891465-3b02-4874-bf8d-cab7d33eb908"), "Well-head Level"));
            }

            IsHiddenDepthReference = depthReferences.Count <= 1;

            if (WellHeadPositionReferenceSource != null)
            {
                positionReferences.Add(new Tuple<Guid, string>(new Guid("443ffbd3-d0ab-43a1-b41e-ac2c54976e49"), "Well-head"));
            }
            if (ClusterPositionReferenceSource != null)
            {
                positionReferences.Add(new Tuple<Guid, string>(new Guid("109fc958-bf9c-454d-9505-6a3c34d0a501"), "Cluster-reference"));
            }
            if (LeaseLinePositionReferenceSource != null)
            {
                positionReferences.Add(new Tuple<Guid, string>(new Guid("4bcd2794-e868-40db-aee6-4082cbba4fae"), "Lease-line"));
            }
            if (CartographicGridPositionReferenceSource != null)
            {
                positionReferences.Add(new Tuple<Guid, string>(new Guid("073a7b94-09ac-4c9e-a7bb-03de2684123b"), "Cartographic"));
            }
            positionReferences.Add(new Tuple<Guid, string>(new Guid("94631afe-61f1-494e-96a0-91f0593285c4"), "WGS84"));

            IsHiddenPositionReference = positionReferences.Count <= 1;

            azimuthReferences.Add(new Tuple<Guid, string>(new Guid("73cb739b-aae1-4dcb-a1ed-0aad5a62a6bd"), "True North"));
            if (GridConvergenceSource != null)
            {
                azimuthReferences.Add(new Tuple<Guid, string>(new Guid("7c3b58ff-542c-4ff7-a3a1-44efd3ba7627"), "Grid North"));
            }
            if (MagneticDeclinationSource != null)
            {
                azimuthReferences.Add(new Tuple<Guid, string>(new Guid("fd21b812-338b-4401-a2be-1a4d7d3756b1"), "Magnetic North"));
            }
            IsHiddenAzimuthReference = azimuthReferences.Count <= 1;

            pressureReferences.Add(new Tuple<Guid, string>(new Guid("ffb90df3-d692-4502-9332-d74ddd61b67f"), "Absolute Pressure"));
            if (GaugeReferencePressureSource != null)
            {
                pressureReferences.Add(new Tuple<Guid, string>(new Guid("28ade755-e07a-4580-b51f-10507832db92"), "Gauge Pressure"));
            }
            IsHiddenPressureReference = pressureReferences.Count <= 1;

            dateReferences.Add(new Tuple<Guid, string>(new Guid("6fb296eb-eb77-4a6f-82d0-122c74e8d3cf"), "UTC"));
            dateReferences.Add(new Tuple<Guid, string>(new Guid("f0ee13c7-2b9b-46e1-8d57-3fd6070f8a9b"), "Local Time"));

            unitChoiceSets = new List<MetaInfo>();
            unitChoiceSets.Clear();
            if (!string.IsNullOrEmpty(HttpHost) &&
                !string.IsNullOrEmpty(HttpBasePath) &&
                !string.IsNullOrEmpty(HttpController))
            {
                //Case when a controller of DrillingUnitChoiceSets is defined
                //    - this offers the possibility to define custom DrillingUnitChoiceSets
                //    - the child razor component of the present one (this) must indicate how to send requests to this controller (route, endpoint)
                httpClient = new HttpClient
                    {
                        BaseAddress = new Uri(HttpHost + HttpBasePath)
                    };
                httpClient.DefaultRequestHeaders.Accept.Clear();
                httpClient.DefaultRequestHeaders.Accept.Add(new System.Net.Http.Headers.MediaTypeWithQualityHeaderValue("application/json"));
                try
                {
                    var a = await httpClient.GetAsync(HttpController + "MetaInfos/");
                    if (a.IsSuccessStatusCode)
                    {
                        string str = await a.Content.ReadAsStringAsync();
                        if (!string.IsNullOrEmpty(str))
                        {
                            unitChoiceSets = Newtonsoft.Json.JsonConvert.DeserializeObject<List<MetaInfo>>(str);
                        }
                    }
                }
                catch (Exception e)
                {
                }
            }
            else
            {
                //Case when no controller is available: default UnitChoiceSets are used
                UnitChoiceSet SIUnitChoiceSet = DrillingUnitChoiceSet.DrillingSIUnitChoiceSet;
                if (SIUnitChoiceSet != null)
                {
                    unitChoiceSets.Add(new MetaInfo(SIUnitChoiceSet.ID, SIUnitChoiceSet.Name));
                }
                UnitChoiceSet metricUnitChoiceSet = DrillingUnitChoiceSet.DrillingMetricUnitChoiceSet;
                if (metricUnitChoiceSet != null)
                {
                    unitChoiceSets.Add(new MetaInfo(metricUnitChoiceSet.ID, metricUnitChoiceSet.Name));
                }
                UnitChoiceSet imperialUnitChoiceSet = DrillingUnitChoiceSet.DrillingImperialUnitChoiceSet;
                if (imperialUnitChoiceSet != null)
                {
                    unitChoiceSets.Add(new MetaInfo(imperialUnitChoiceSet.ID, imperialUnitChoiceSet.Name));
                }
                UnitChoiceSet USUnitChoiceSet = DrillingUnitChoiceSet.DrillingUSUnitChoiceSet;
                if (USUnitChoiceSet != null)
                {
                    unitChoiceSets.Add(new MetaInfo(USUnitChoiceSet.ID, USUnitChoiceSet.Name));
                }
            }
            //Initializing unitChoiceSet_ and associated UnitChoiceSetName: default value or checking the validity of the given one
            MetaInfo defaultMetaInfo = null;
            if (unitChoiceSets != null)
            {
                unitChoiceSets.Sort((x, y) => Comparer<string>.Default.Compare(x.Name, y.Name));
                foreach (MetaInfo metaInfo in unitChoiceSets)
                {
                    //unitChoiceSets.Add(metaInfo);
                    defaultMetaInfo = metaInfo;
                    if (string.IsNullOrEmpty(UnitChoiceSetName) || UnitChoiceSetName.Equals(metaInfo.Name))
                        break; //the given UnitChoiceSetName is checked against each name in the available unitChoiceSets
                }
                //                unitChoiceSet_ = DrillingUnitChoiceSet.Get(defaultMetaInfo.ID);
                if (defaultMetaInfo != null)
                    UnitChoiceSetName = defaultMetaInfo.Name; //eventually, the UnitChoiceSetName is set to an existing unitChoiceSet (if there are any), by default the last available is "US"
            }
            await InvokeAsync(() => { StateHasChanged(); });
        }
        catch (Exception ex)
        {
        }
    }

    public void Add(IUnitAwareComponent elt)
    {
        unitAwareComponents_.Add(elt);
    }
    public void Add(IDateTimeReferenceAwareComponent elt)
    {
        dateTimeAwareComponents_.Add(elt);
    }
    #region management of units without references
    public string FromSI(double? val, string quantityName, bool useUnitLabel)
    {
        if (val == null)
        {
            return "";
        }
        if (string.IsNullOrEmpty(quantityName) || unitChoiceSet_ == null)
        {
            return val.ToString();
        }
        string result = unitChoiceSet_.FromSIString(quantityName, (double)val);
        if (useUnitLabel)
        {
            result += " " + unitChoiceSet_.GetUnitLabel(quantityName);
        }
        return result;
    }

    public double? FromSI(double? val, string quantityName)
    {
        if (val == null)
        {
            return null;
        }
        else
        {
            return FromSI((double)val, quantityName);
        }
    }

    public double FromSI(double val, string quantityName)
    {
        if (string.IsNullOrEmpty(quantityName) || unitChoiceSet_ == null)
        {
            return val;
        }
        double? res = unitChoiceSet_.FromSI(quantityName, val);
        if (res == null)
        {
            return double.NaN;
        }
        else
        {
            return (double)res;
        }
    }

    public string GetUnitLabel(string quantityName)
    {
        if (unitChoiceSet_ != null)
        {
            return unitChoiceSet_.GetUnitLabel(quantityName);
        }
        else
        {
            return "";
        }
    }

    public double ToSI(double val, string quantityName)
    {
        if (string.IsNullOrEmpty(quantityName) || unitChoiceSet_ == null)
        {
            return val;
        }
        OSDC.UnitConversion.Conversion.UnitChoice choice = unitChoiceSet_.GetChoice(quantityName);
        if (choice != null)
        {
            return choice.ToSI(val);
        }
        else
        {
            return val;
        }
    }
    #endregion

    #region management of references for datetime
    public string TimeFromUTC(DateTime? val)
    {
        Guid id = Guid.Empty;
        foreach (Tuple<Guid, string> tuple in dateReferences)
        {
            if (tuple.Item2 == DateReferenceName)
            {
                id = tuple.Item1;
                break;
            }
        }
        if (id != Guid.Empty && val != null)
        {
            if (id == new Guid("f0ee13c7-2b9b-46e1-8d57-3fd6070f8a9b")) // local time
            {
                return ((DateTime)val).ToLocalTime().ToLongTimeString();
            }
            else
            {
                return ((DateTime)val).ToLongTimeString();
            }
        }
        else
        {
            return "";
        }
    }
    public string DateFromUTC(DateTime? val)
    {
        Guid id = Guid.Empty;
        foreach (Tuple<Guid, string> tuple in dateReferences)
        {
            if (tuple.Item2 == DateReferenceName)
            {
                id = tuple.Item1;
                break;
            }
        }
        if (id != Guid.Empty && val != null)
        {
            if (id == new Guid("f0ee13c7-2b9b-46e1-8d57-3fd6070f8a9b")) // local time
            {
                return ((DateTime)val).ToLocalTime().ToLongDateString();
            }
            else
            {
                return ((DateTime)val).ToLongDateString();
            }
        }
        else
        {
            return "";
        }
    }

    public string DateTimeFromUTC(DateTime? val)
    {
        Guid id = Guid.Empty;
        foreach (Tuple<Guid, string> tuple in dateReferences)
        {
            if (tuple.Item2 == DateReferenceName)
            {
                id = tuple.Item1;
                break;
            }
        }
        if (id != Guid.Empty && val != null)
        {
            if (id == new Guid("f0ee13c7-2b9b-46e1-8d57-3fd6070f8a9b")) // local time
            {
                return ((DateTime)val).ToLocalTime().ToLongDateString() + " " + ((DateTime)val).ToLocalTime().ToLongTimeString();
            }
            else
            {
                return ((DateTime)val).ToLongDateString() + " " + ((DateTime)val).ToLongTimeString();
            }
        }
        else
        {
            return "";
        }
    }

    public DateTime ToUTC(DateTime val)
    {
        Guid id = Guid.Empty;
        foreach (Tuple<Guid, string> tuple in dateReferences)
        {
            if (tuple.Item2 == DateReferenceName)
            {
                id = tuple.Item1;
                break;
            }
        }
        if (id == Guid.Empty)
        {
            return val;
        }
        if (id == new Guid("f0ee13c7-2b9b-46e1-8d57-3fd6070f8a9b")) // local time
        {
            return val.ToUniversalTime();
        }
        else
        {
            return val;
        }
    }
    #endregion

    #region management of references for pressure
    public string FromAbsolutePressureSI(double? val, string quantityName, bool useUnitLabel)
    {
        if (!IsPressure(quantityName))
        {
            return "";
        }
        if (val == null)
        {
            return "";
        }
        double delta = 0;
        Guid id = Guid.Empty;
        foreach (Tuple<Guid, string> tuple in pressureReferences)
        {
            if (tuple.Item2 == pressureReferenceName_)
            {
                id = tuple.Item1;
                break;
            }
        }
        if (id == new Guid("28ade755-e07a-4580-b51f-10507832db92") &&
            GaugeReferencePressureSource != null &&
            GaugeReferencePressureSource.GaugeReferencePressure != null) // gauge
        {
            delta = (double)GaugeReferencePressureSource.GaugeReferencePressure;
            val -= delta;
        }
        string valueInUserUnit = FromSI(val, quantityName, false);
        if (useUnitLabel)
        {
            return valueInUserUnit + " " + GetPressureUnitLabel(quantityName);
        }
        else
        {
            return valueInUserUnit;
        }
    }
    public double? FromAbsolutePressureSI(double? val, string quantityName)
    {
        if (val == null)
        {
            return null;
        }
        else
        {
            return FromAbsolutePressureSI((double)val, quantityName);
        }
    }
    public double FromAbsolutePressureSI(double val, string quantityName)
    {
        if (!IsPressure(quantityName))
        {
            return double.NaN;
        }
        double delta = 0;
        Guid id = Guid.Empty;
        foreach (Tuple<Guid, string> tuple in pressureReferences)
        {
            if (tuple.Item2 == pressureReferenceName_)
            {
                id = tuple.Item1;
                break;
            }
        }
        if (id == new Guid("28ade755-e07a-4580-b51f-10507832db92") &&
            GaugeReferencePressureSource != null &&
            GaugeReferencePressureSource.GaugeReferencePressure != null) // gauge
        {
            delta = (double)GaugeReferencePressureSource.GaugeReferencePressure;
            val -= delta;
        }
        return FromSI(val, quantityName);
    }

    public string GetPressureUnitLabel(string quantityName)
    {
        if (!IsPressure(quantityName))
        {
            return "";
        }
        if (unitChoiceSet_ != null)
        {
            string label = unitChoiceSet_.GetUnitLabel(quantityName);
            if (!string.IsNullOrEmpty(label))
            {
                Guid id = Guid.Empty;
                foreach (Tuple<Guid, string> tuple in pressureReferences)
                {
                    if (tuple.Item2 == pressureReferenceName_)
                    {
                        id = tuple.Item1;
                        break;
                    }
                }
                if (id == new Guid("28ade755-e07a-4580-b51f-10507832db92")) // gauge
                {
                    return label + "g";
                }
                else
                {
                    return label + "a";
                }
            }
            else
            {
                return label;
            }
        }
        else
        {
            return "";
        }
    }
    public double ToAbsolutePressureSI(double v, string quantityName)
    {
        if (!IsPressure(quantityName))
        {
            return double.NaN;
        }
        double val = ToSI(v, quantityName);
        double delta = 0;
        Guid id = Guid.Empty;
        foreach (Tuple<Guid, string> tuple in pressureReferences)
        {
            if (tuple.Item2 == pressureReferenceName_)
            {
                id = tuple.Item1;
                break;
            }
        }
        if (id == new Guid("28ade755-e07a-4580-b51f-10507832db92") &&
            GaugeReferencePressureSource != null &&
            GaugeReferencePressureSource.GaugeReferencePressure != null) // gauge
        {
            delta = (double)GaugeReferencePressureSource.GaugeReferencePressure;
            val += delta;
        }
        return val;
    }

    private bool IsPressure(string quantityName)
    {
        OSDC.UnitConversion.Conversion.PhysicalQuantity quantity = DrillingPhysicalQuantity.GetQuantity(quantityName);
        return quantity != null &&
               quantity.TimeDimension == -2 &&
               quantity.MassDimension == 1 &&
               quantity.LengthDimension == -1 &&
               quantity.LuminousIntensityDimension == 0 &&
               quantity.AmountSubstanceDimension == 0 &&
               quantity.ElectricCurrentDimension == 0 &&
               quantity.SolidAngleDimension == 0 &&
               quantity.PlaneAngleDimension == 0;
    }
    #endregion

    #region management of references for azimuths
    public string FromTrueNorthAzimuthSI(double? val, string quantityName, bool useUnitLabel)
    {
        if (!IsPlaneAngle(quantityName))
        {
            return "";
        }
        if (val == null)
        {
            return "";
        }
        double delta = 0;
        Guid id = Guid.Empty;
        foreach (Tuple<Guid, string> tuple in azimuthReferences)
        {
            if (tuple.Item2 == azimuthReferenceName_)
            {
                id = tuple.Item1;
                break;
            }
        }
        if (id == new Guid("7c3b58ff-542c-4ff7-a3a1-44efd3ba7627") &&
            GridConvergenceSource != null &&
            GridConvergenceSource.GridConvergence != null) // grid north
        {
            delta = (double)GridConvergenceSource.GridConvergence;
            val += delta; // the grid convergence is the angle to move from true north to grid north
        }
        else if (id == new Guid("fd21b812-338b-4401-a2be-1a4d7d3756b1") &&
            MagneticDeclinationSource != null &&
            MagneticDeclinationSource.MagneticDeclination != null) // magnetic north
        {
            delta = (double)MagneticDeclinationSource.MagneticDeclination;
            val += delta; // the magnetic declination is the angle to move from true north to magnetic north
        }
        string valueInUserUnit = FromSI(val, quantityName, false);
        if (useUnitLabel)
        {
            return valueInUserUnit + " " + GetAzimuthUnitLabel(quantityName);
        }
        else
        {
            return valueInUserUnit;
        }
    }
    public double? FromTrueNorthAzimuthSI(double? val, string quantityName)
    {
        if (val == null)
        {
            return null;
        }
        else
        {
            return FromTrueNorthAzimuthSI((double)val, quantityName);
        }
    }
    public double FromTrueNorthAzimuthSI(double val, string quantityName)
    {
        if (!IsPlaneAngle(quantityName))
        {
            return double.NaN;
        }
        double delta = 0;
        Guid id = Guid.Empty;
        foreach (Tuple<Guid, string> tuple in azimuthReferences)
        {
            if (tuple.Item2 == azimuthReferenceName_)
            {
                id = tuple.Item1;
                break;
            }
        }
        if (id == new Guid("7c3b58ff-542c-4ff7-a3a1-44efd3ba7627") &&
            GridConvergenceSource != null &&
            GridConvergenceSource.GridConvergence != null) // grid north
        {
            delta = (double)GridConvergenceSource.GridConvergence;
            val += delta; // the grid convergence is the angle to move from true north to grid north
        }
        else if (id == new Guid("fd21b812-338b-4401-a2be-1a4d7d3756b1") &&
            MagneticDeclinationSource != null &&
            MagneticDeclinationSource.MagneticDeclination != null) // magnetic north
        {
            delta = (double)MagneticDeclinationSource.MagneticDeclination;
            val += delta; // the magnetic declination is the angle to move from true north to magnetic north
        }
        return FromSI(val, quantityName);
    }

    public string GetAzimuthUnitLabel(string quantityName)
    {
        if (!IsPlaneAngle(quantityName))
        {
            return "";
        }
        if (unitChoiceSet_ != null)
        {
            string label = unitChoiceSet_.GetUnitLabel(quantityName);
            if (!string.IsNullOrEmpty(label))
            {
                Guid id = Guid.Empty;
                foreach (Tuple<Guid, string> tuple in azimuthReferences)
                {
                    if (tuple.Item2 == azimuthReferenceName_)
                    {
                        id = tuple.Item1;
                        break;
                    }
                }
                if (id == new Guid("7c3b58ff-542c-4ff7-a3a1-44efd3ba7627") &&
                    GridConvergenceSource != null &&
                    GridConvergenceSource.GridConvergence != null) // grid north
                {
                    return label + "GN";
                }
                else if (id == new Guid("fd21b812-338b-4401-a2be-1a4d7d3756b1") &&
                         MagneticDeclinationSource != null &&
                         MagneticDeclinationSource.MagneticDeclination != null) // magnetic north
                {
                    return label + "MN";
                }
                else
                {
                    return label + "TN";
                }

            }
            else
            {
                return label;
            }
        }
        else
        {
            return "";
        }
    }
    public double ToTrueNorthAzimuthSI(double v, string quantityName)
    {
        if (!IsPlaneAngle(quantityName))
        {
            return double.NaN;
        }
        double val = ToSI(v, quantityName);
        double delta = 0;
        Guid id = Guid.Empty;
        foreach (Tuple<Guid, string> tuple in azimuthReferences)
        {
            if (tuple.Item2 == azimuthReferenceName_)
            {
                id = tuple.Item1;
                break;
            }
        }
        if (id == new Guid("7c3b58ff-542c-4ff7-a3a1-44efd3ba7627") &&
            GridConvergenceSource != null &&
            GridConvergenceSource.GridConvergence != null) // grid north
        {
            delta = (double)GridConvergenceSource.GridConvergence;
            val -= delta; // the grid convergence is the angle to move from true north to grid north
        }
        else if (id == new Guid("fd21b812-338b-4401-a2be-1a4d7d3756b1") &&
            MagneticDeclinationSource != null &&
            MagneticDeclinationSource.MagneticDeclination != null) // magnetic north
        {
            delta = (double)MagneticDeclinationSource.MagneticDeclination;
            val -= delta; // the magnetic declination is the angle to move from true north to magnetic north
        }
        return val;
    }

    private bool IsPlaneAngle(string quantityName)
    {
        OSDC.UnitConversion.Conversion.PhysicalQuantity quantity = DrillingPhysicalQuantity.GetQuantity(quantityName);
        return quantity != null &&
               quantity.TimeDimension == 0 &&
               quantity.MassDimension == 0 &&
               quantity.LengthDimension == 0 &&
               quantity.LuminousIntensityDimension == 0 &&
               quantity.AmountSubstanceDimension == 0 &&
               quantity.ElectricCurrentDimension == 0 &&
               quantity.SolidAngleDimension == 0 &&
               quantity.PlaneAngleDimension == 1;
    }
    #endregion

    #region management of references for depths
    public string FromWGS84DepthSI(double? val, string quantityName, bool useUnitLabel)
    {
        if (!IsLength(quantityName))
        {
            return "";
        }
        if (val == null)
        {
            return "";
        }
        double delta = 0;
        Guid id = Guid.Empty;
        foreach (Tuple<Guid, string> tuple in depthReferences)
        {
            if (tuple.Item2 == depthReferenceName_)
            {
                id = tuple.Item1;
                break;
            }
        }
        if (id == new Guid("4d4fd143-b00d-4575-b9f2-a7ea4047e9d3") &&
            RotaryTableDepthReferenceSource != null &&
            RotaryTableDepthReferenceSource.RotaryTableDepthReference != null) // rotary table
        {
            delta = (double)RotaryTableDepthReferenceSource.RotaryTableDepthReference;
            val += delta; // the RotaryTableDepthReference is the depth (positive downward) to move from WGS84 to rotary table reference
        }
        else if (id == new Guid("98f55f50-e9e1-4045-8b2f-b03e6b96e1d1") &&
            SeaWaterLevelDepthReferenceSource != null &&
            SeaWaterLevelDepthReferenceSource.SeaWaterLevelDepthReference != null) // sea or water level (lake, river)
        {
            delta = (double)SeaWaterLevelDepthReferenceSource.SeaWaterLevelDepthReference;
            val += delta; // the SeaWaterLevelDepthReference is the depth (positive downward) to move from WGS84 to sea or water level
        }
        else if (id == new Guid("a4667d26-3bb2-40ac-b26f-9346d1441e4a") &&
                 GroundMudLineDepthReferenceSource != null &&
                 GroundMudLineDepthReferenceSource.GroundMudLineDepthReference != null) // ground level or mud line
        {
            delta = (double)GroundMudLineDepthReferenceSource.GroundMudLineDepthReference;
            val += delta; // the GroundMudLineDepthReference is the depth (positive downward) to move from WGS84 to ground level or the mud line
        }
        else if (id == new Guid("51891465-3b02-4874-bf8d-cab7d33eb908") &&
                 WellHeadDepthReferenceSource != null &&
                 WellHeadDepthReferenceSource.WellHeadDepthReference != null) // well-head
        {
            delta = (double)WellHeadDepthReferenceSource.WellHeadDepthReference;
            val += delta; // the WellHeadDepthReference is the depth (positive downward) to move from WGS84 to the well-head
        }

        string valueInUserUnit = FromSI(val, quantityName, false);
        if (useUnitLabel)
        {
            return valueInUserUnit + " " + GetDepthUnitLabel(quantityName);
        }
        else
        {
            return valueInUserUnit;
        }
    }
    public double? FromWGS84DepthSI(double? val, string quantityName)
    {
        if (val == null)
        {
            return null;
        }
        else
        {
            return FromWGS84DepthSI((double)val, quantityName);
        }
    }
    public double FromWGS84DepthSI(double val, string quantityName)
    {
        if (!IsLength(quantityName))
        {
            return double.NaN;
        }
        double delta = 0;
        Guid id = Guid.Empty;
        foreach (Tuple<Guid, string> tuple in depthReferences)
        {
            if (tuple.Item2 == depthReferenceName_)
            {
                id = tuple.Item1;
                break;
            }
        }
        if (id == new Guid("4d4fd143-b00d-4575-b9f2-a7ea4047e9d3") &&
            RotaryTableDepthReferenceSource != null &&
            RotaryTableDepthReferenceSource.RotaryTableDepthReference != null) // rotary table
        {
            delta = (double)RotaryTableDepthReferenceSource.RotaryTableDepthReference;
            val += delta; // the RotaryTableDepthReference is the depth (positive downward) to move from WGS84 to rotary table reference
        }
        else if (id == new Guid("98f55f50-e9e1-4045-8b2f-b03e6b96e1d1") &&
            SeaWaterLevelDepthReferenceSource != null &&
            SeaWaterLevelDepthReferenceSource.SeaWaterLevelDepthReference != null) // sea or water level (lake, river)
        {
            delta = (double)SeaWaterLevelDepthReferenceSource.SeaWaterLevelDepthReference;
            val += delta; // the SeaWaterLevelDepthReference is the depth (positive downward) to move from WGS84 to sea or water level
        }
        else if (id == new Guid("a4667d26-3bb2-40ac-b26f-9346d1441e4a") &&
                 GroundMudLineDepthReferenceSource != null &&
                 GroundMudLineDepthReferenceSource.GroundMudLineDepthReference != null) // ground level or mud line
        {
            delta = (double)GroundMudLineDepthReferenceSource.GroundMudLineDepthReference;
            val += delta; // the GroundMudLineDepthReference is the depth (positive downward) to move from WGS84 to ground level or the mud line
        }
        else if (id == new Guid("51891465-3b02-4874-bf8d-cab7d33eb908") &&
                 WellHeadDepthReferenceSource != null &&
                 WellHeadDepthReferenceSource.WellHeadDepthReference != null) // well-head
        {
            delta = (double)WellHeadDepthReferenceSource.WellHeadDepthReference;
            val += delta; // the WellHeadDepthReference is the depth (positive downward) to move from WGS84 to the well-head
        }
        return FromSI(val, quantityName);
    }

    public string GetDepthUnitLabel(string quantityName)
    {
        if (!IsLength(quantityName))
        {
            return "";
        }
        if (unitChoiceSet_ != null)
        {
            string label = unitChoiceSet_.GetUnitLabel(quantityName);
            if (!string.IsNullOrEmpty(label))
            {
                Guid id = Guid.Empty;
                foreach (Tuple<Guid, string> tuple in depthReferences)
                {
                    if (tuple.Item2 == depthReferenceName_)
                    {
                        id = tuple.Item1;
                        break;
                    }
                }
                if (id == new Guid("4d4fd143-b00d-4575-b9f2-a7ea4047e9d3") &&
                    RotaryTableDepthReferenceSource != null &&
                    RotaryTableDepthReferenceSource.RotaryTableDepthReference != null) // rotary table
                {
                    return label + "RTE";
                }
                else if (id == new Guid("98f55f50-e9e1-4045-8b2f-b03e6b96e1d1") &&
                    SeaWaterLevelDepthReferenceSource != null &&
                    SeaWaterLevelDepthReferenceSource.SeaWaterLevelDepthReference != null) // sea or water level (lake, river)
                {
                    return label + "SL-WL";
                }
                else if (id == new Guid("a4667d26-3bb2-40ac-b26f-9346d1441e4a") &&
                     GroundMudLineDepthReferenceSource != null &&
                     GroundMudLineDepthReferenceSource.GroundMudLineDepthReference != null) // ground level or mud line
                {
                    return label + "GL-ML";
                }
                else if (id == new Guid("51891465-3b02-4874-bf8d-cab7d33eb908") &&
                     WellHeadDepthReferenceSource != null &&
                     WellHeadDepthReferenceSource.WellHeadDepthReference != null) // well-head
                {
                    return label + "WHE";
                }
                else
                {
                    return label + "WGS84";
                }
            }
            else
            {
                return label;
            }
        }
        else
        {
            return "";
        }
    }
    public double ToWGS84DepthSI(double v, string quantityName)
    {
        if (!IsLength(quantityName))
        {
            return double.NaN;
        }
        double val = ToSI(v, quantityName);
        double delta = 0;
        Guid id = Guid.Empty;
        foreach (Tuple<Guid, string> tuple in depthReferences)
        {
            if (tuple.Item2 == depthReferenceName_)
            {
                id = tuple.Item1;
                break;
            }
        }
        if (id == new Guid("4d4fd143-b00d-4575-b9f2-a7ea4047e9d3") &&
            RotaryTableDepthReferenceSource != null &&
            RotaryTableDepthReferenceSource.RotaryTableDepthReference != null) // rotary table
        {
            delta = (double)RotaryTableDepthReferenceSource.RotaryTableDepthReference;
            val -= delta; // the RotaryTableDepthReference is the depth (positive downward) to move from WGS84 to rotary table reference
        }
        else if (id == new Guid("98f55f50-e9e1-4045-8b2f-b03e6b96e1d1") &&
            SeaWaterLevelDepthReferenceSource != null &&
            SeaWaterLevelDepthReferenceSource.SeaWaterLevelDepthReference != null) // sea or water level (lake, river)
        {
            delta = (double)SeaWaterLevelDepthReferenceSource.SeaWaterLevelDepthReference;
            val -= delta; // the SeaWaterLevelDepthReference is the depth (positive downward) to move from WGS84 to sea or water level
        }
        else if (id == new Guid("a4667d26-3bb2-40ac-b26f-9346d1441e4a") &&
                 GroundMudLineDepthReferenceSource != null &&
                 GroundMudLineDepthReferenceSource.GroundMudLineDepthReference != null) // ground level or mud line
        {
            delta = (double)GroundMudLineDepthReferenceSource.GroundMudLineDepthReference;
            val -= delta; // the GroundMudLineDepthReference is the depth (positive downward) to move from WGS84 to ground level or the mud line
        }
        else if (id == new Guid("51891465-3b02-4874-bf8d-cab7d33eb908") &&
                 WellHeadDepthReferenceSource != null &&
                 WellHeadDepthReferenceSource.WellHeadDepthReference != null) // well-head
        {
            delta = (double)WellHeadDepthReferenceSource.WellHeadDepthReference;
            val -= delta; // the WellHeadDepthReference is the depth (positive downward) to move from WGS84 to the well-head
        }
        return val;
    }

    private bool IsLength(string quantityName)
    {
        OSDC.UnitConversion.Conversion.PhysicalQuantity quantity = DrillingPhysicalQuantity.GetQuantity(quantityName);
        return quantity != null &&
               quantity.TimeDimension == 0 &&
               quantity.MassDimension == 0 &&
               quantity.LengthDimension == 1 &&
               quantity.LuminousIntensityDimension == 0 &&
               quantity.AmountSubstanceDimension == 0 &&
               quantity.ElectricCurrentDimension == 0 &&
               quantity.SolidAngleDimension == 0 &&
               quantity.PlaneAngleDimension == 0;
    }
    #endregion

    #region management of references for position
    public string FromWGS84PositionSI(double? val, string quantityName, bool useUnitLabel, PositionDirectionType direction)
    {
        if (!IsLength(quantityName))
        {
            return "";
        }
        if (val == null)
        {
            return "";
        }
        if (direction == PositionDirectionType.Independent)
        {
            return "";
        }
        double delta = 0;
        Guid id = Guid.Empty;
        foreach (Tuple<Guid, string> tuple in positionReferences)
        {
            if (tuple.Item2 == positionReferenceName_)
            {
                id = tuple.Item1;
                break;
            }
        }
        if (id == new Guid("443ffbd3-d0ab-43a1-b41e-ac2c54976e49") &&
            WellHeadPositionReferenceSource != null &&
            WellHeadPositionReferenceSource.WellHeadNorthPositionReference != null &&
            WellHeadPositionReferenceSource.WellHeadEastPositionReference != null) // well-head position reference
        {
            if (direction == PositionDirectionType.North)
            {
                delta = (double)WellHeadPositionReferenceSource.WellHeadNorthPositionReference;
            }
            else
            {
                delta = (double)WellHeadPositionReferenceSource.WellHeadEastPositionReference;
            }
            val += delta;
        }
        else if (id == new Guid("109fc958-bf9c-454d-9505-6a3c34d0a501") &&
            ClusterPositionReferenceSource != null &&
            ClusterPositionReferenceSource.ClusterNorthPositionReference != null &&
            ClusterPositionReferenceSource.ClusterEastPositionReference != null) //cluster position reference
        {
            if (direction == PositionDirectionType.North)
            {
                delta = (double)ClusterPositionReferenceSource.ClusterNorthPositionReference;
            }
            else
            {
                delta = (double)ClusterPositionReferenceSource.ClusterEastPositionReference;
            }
            val += delta;
        }
        else if (id == new Guid("4bcd2794-e868-40db-aee6-4082cbba4fae") &&
                 CartographicGridPositionReferenceSource != null &&
                 CartographicGridPositionReferenceSource.CartographicGridNorthPositionReference != null &&
                 CartographicGridPositionReferenceSource.CartographicGridEastPositionReference != null) // cartographic position reference
        {
            if (direction == PositionDirectionType.North)
            {
                delta = (double)CartographicGridPositionReferenceSource.CartographicGridNorthPositionReference;
            }
            else
            {
                delta = (double)CartographicGridPositionReferenceSource.CartographicGridEastPositionReference;
            }
            val += delta;
        }
        string valueInUserUnit = FromSI(val, quantityName, false);
        if (useUnitLabel)
        {
            return valueInUserUnit + " " + GetPositionUnitLabel(quantityName);
        }
        else
        {
            return valueInUserUnit;
        }
    }
    public double? FromWGS84PositionSI(double? val, string quantityName, PositionDirectionType direction)
    {
        if (val == null)
        {
            return null;
        }
        else
        {
            return FromWGS84PositionSI((double)val, quantityName, direction);
        }
    }
    public double FromWGS84PositionSI(double val, string quantityName, PositionDirectionType direction)
    {
        if (!IsLength(quantityName))
        {
            return double.NaN;
        }
        if (direction == PositionDirectionType.Independent)
        {
            return double.NaN;
        }
        double delta = 0;
        Guid id = Guid.Empty;
        foreach (Tuple<Guid, string> tuple in positionReferences)
        {
            if (tuple.Item2 == positionReferenceName_)
            {
                id = tuple.Item1;
                break;
            }
        }
        if (id == new Guid("443ffbd3-d0ab-43a1-b41e-ac2c54976e49") &&
             WellHeadPositionReferenceSource != null &&
             WellHeadPositionReferenceSource.WellHeadNorthPositionReference != null &&
             WellHeadPositionReferenceSource.WellHeadEastPositionReference != null) // well-head position reference
        {
            if (direction == PositionDirectionType.North)
            {
                delta = (double)WellHeadPositionReferenceSource.WellHeadNorthPositionReference;
            }
            else
            {
                delta = (double)WellHeadPositionReferenceSource.WellHeadEastPositionReference;
            }
            val += delta;
        }
        else if (id == new Guid("109fc958-bf9c-454d-9505-6a3c34d0a501") &&
            ClusterPositionReferenceSource != null &&
            ClusterPositionReferenceSource.ClusterNorthPositionReference != null &&
            ClusterPositionReferenceSource.ClusterEastPositionReference != null) //cluster position reference
        {
            if (direction == PositionDirectionType.North)
            {
                delta = (double)ClusterPositionReferenceSource.ClusterNorthPositionReference;
            }
            else
            {
                delta = (double)ClusterPositionReferenceSource.ClusterEastPositionReference;
            }
            val += delta;
        }
        else if (id == new Guid("4bcd2794-e868-40db-aee6-4082cbba4fae") &&
                 CartographicGridPositionReferenceSource != null &&
                 CartographicGridPositionReferenceSource.CartographicGridNorthPositionReference != null &&
                 CartographicGridPositionReferenceSource.CartographicGridEastPositionReference != null) // cartographic position reference
        {
            if (direction == PositionDirectionType.North)
            {
                delta = (double)CartographicGridPositionReferenceSource.CartographicGridNorthPositionReference;
            }
            else
            {
                delta = (double)CartographicGridPositionReferenceSource.CartographicGridEastPositionReference;
            }
            val += delta;
        }
        return FromSI(val, quantityName);
    }

    public string GetPositionUnitLabel(string quantityName)
    {
        if (!IsLength(quantityName))
        {
            return "";
        }
        if (unitChoiceSet_ != null)
        {
            string label = unitChoiceSet_.GetUnitLabel(quantityName);
            if (!string.IsNullOrEmpty(label))
            {
                Guid id = Guid.Empty;
                foreach (Tuple<Guid, string> tuple in positionReferences)
                {
                    if (tuple.Item2 == positionReferenceName_)
                    {
                        id = tuple.Item1;
                        break;
                    }
                }
                if (id == new Guid("443ffbd3-d0ab-43a1-b41e-ac2c54976e49") &&
                    WellHeadPositionReferenceSource != null &&
                    WellHeadPositionReferenceSource.WellHeadNorthPositionReference != null &&
                    WellHeadPositionReferenceSource.WellHeadEastPositionReference != null) // well-head position reference
                {
                    return label + "WE";
                }
                else if (id == new Guid("109fc958-bf9c-454d-9505-6a3c34d0a501") &&
                         ClusterPositionReferenceSource != null &&
                         ClusterPositionReferenceSource.ClusterNorthPositionReference != null &&
                         ClusterPositionReferenceSource.ClusterEastPositionReference != null) //cluster position reference
                {
                    return label + "CR";
                }
                else if (id == new Guid("4bcd2794-e868-40db-aee6-4082cbba4fae") &&
                         CartographicGridPositionReferenceSource != null &&
                         CartographicGridPositionReferenceSource.CartographicGridNorthPositionReference != null &&
                         CartographicGridPositionReferenceSource.CartographicGridEastPositionReference != null) // cartographic position reference
                {
                    return label + "Grid";
                }
                else
                {
                    return label + "WGS84";
                }
            }
            else
            {
                return label;
            }
        }
        else
        {
            return "";
        }
    }
    public double ToWGS84PositionSI(double v, string quantityName, PositionDirectionType direction)
    {
        if (!IsLength(quantityName))
        {
            return double.NaN;
        }
        if (direction == PositionDirectionType.Independent)
        {
            return double.NaN;
        }
        double val = ToSI(v, quantityName);
        double delta = 0;
        Guid id = Guid.Empty;
        foreach (Tuple<Guid, string> tuple in positionReferences)
        {
            if (tuple.Item2 == positionReferenceName_)
            {
                id = tuple.Item1;
                break;
            }
        }
        if (id == new Guid("443ffbd3-d0ab-43a1-b41e-ac2c54976e49") &&
            WellHeadPositionReferenceSource != null &&
            WellHeadPositionReferenceSource.WellHeadNorthPositionReference != null &&
            WellHeadPositionReferenceSource.WellHeadEastPositionReference != null) // well-head position reference
        {
            if (direction == PositionDirectionType.North)
            {
                delta = (double)WellHeadPositionReferenceSource.WellHeadNorthPositionReference;
            }
            else
            {
                delta = (double)WellHeadPositionReferenceSource.WellHeadEastPositionReference;
            }
            val -= delta;
        }
        else if (id == new Guid("109fc958-bf9c-454d-9505-6a3c34d0a501") &&
            ClusterPositionReferenceSource != null &&
            ClusterPositionReferenceSource.ClusterNorthPositionReference != null &&
            ClusterPositionReferenceSource.ClusterEastPositionReference != null) //cluster position reference
        {
            if (direction == PositionDirectionType.North)
            {
                delta = (double)ClusterPositionReferenceSource.ClusterNorthPositionReference;
            }
            else
            {
                delta = (double)ClusterPositionReferenceSource.ClusterEastPositionReference;
            }
            val -= delta;
        }
        else if (id == new Guid("4bcd2794-e868-40db-aee6-4082cbba4fae") &&
                 CartographicGridPositionReferenceSource != null &&
                 CartographicGridPositionReferenceSource.CartographicGridNorthPositionReference != null &&
                 CartographicGridPositionReferenceSource.CartographicGridEastPositionReference != null) // cartographic position reference
        {
            if (direction == PositionDirectionType.North)
            {
                delta = (double)CartographicGridPositionReferenceSource.CartographicGridNorthPositionReference;
            }
            else
            {
                delta = (double)CartographicGridPositionReferenceSource.CartographicGridEastPositionReference;
            }
            val -= delta;
        }
        return val;
    }
    #endregion

    private async void PostProcessUnitChoiceSet()
    {
        UnitChoiceSet unitChoiceSet = null;
        Guid unitChoiceSetID = Guid.Empty;
        if (unitChoiceSets != null)
        {
            foreach (MetaInfo metaInfo in unitChoiceSets)
            {
                if (UnitChoiceSetName == metaInfo.Name)
                {
                    unitChoiceSetID = metaInfo.ID;
                    break;
                }
            }
        }
        if (httpClient != null)
        {
            try
            {
                var a = await httpClient.GetAsync(HttpController + unitChoiceSetID.ToString());
                if (a.IsSuccessStatusCode)
                {
                    string str = await a.Content.ReadAsStringAsync();
                    if (!string.IsNullOrEmpty(str))
                    {
                        unitChoiceSet = Newtonsoft.Json.JsonConvert.DeserializeObject<DrillingUnitChoiceSet>(str);
                    }
                }
            }
            catch (Exception ex)
            {
                unitChoiceSet = null;
            }
        }
        else
        {
            unitChoiceSet = DrillingUnitChoiceSet.Get(unitChoiceSetID);
        }
        unitChoiceSet_ = unitChoiceSet;
        if (unitAwareComponents_ != null)
        {
            foreach (IUnitAwareComponent comp in unitAwareComponents_)
            {
                comp.ManageUnits();
            }
        }
        if (dateTimeAwareComponents_ != null)
        {
            foreach (IDateTimeReferenceAwareComponent comp in dateTimeAwareComponents_)
            {
                comp.ManageDateTimeReference();
            }
        }

        try
        {
            await UnitChoiceSetNameChanged.InvokeAsync(unitChoiceSetName_);
            await InvokeAsync(() => { StateHasChanged(); });
        }
        catch (Exception e)
        {

        }
    }
}